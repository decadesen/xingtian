## 后端选型对比与阶段决策

### 目标与约束
- 目标：为“刑天”提供稳定的数据存储、简单定时任务、未来可扩展的AI教练能力
- 约束：尽快可用、隐私与稳定优先、个人项目的维护成本可控

### 方案对比

1) Supabase（托管Postgres + Auth + Storage + Edge Functions）
- 优势：开箱即用的认证与数据库、行级安全、SQL/REST/RPC、存储与Edge Functions、生态完善
- 成本：零后端自建成本，迭代速度快，前期学习曲线低
- 风险：平台绑定与限额；需理解Postgres与策略（RLS）以保证安全
- 定时任务：pg_cron/Edge Functions可实现

2) 自建Go后端（Go + Postgres/SQLite + 自托管）
- 优势：最大灵活性与可控性；有利于深入工程能力（API设计、并发、部署）
- 成本：架构、部署、监控、CI/CD、日志与安全策略均需自建；上线速度慢
- 风险：维护负担高；需要投入较多时间完善非功能性特性
- 定时任务：自行实现（cron/队列）更灵活但更复杂

### 推荐路径（Two-step）
- 阶段2.1：采用Supabase作为首期后端，快速获得云存储、认证与基础任务；AI教练上下文先以前端+云函数实现
- 阶段2.2：在关键模块上以Go微服务替换或扩展（例如报告生成、AI管道、批处理），逐步积累后端工程能力
-
理由：在项目核心价值（形成每日复盘与行动闭环）尚处迭代期时，优先降低后端门槛与维护成本；待产品形态稳定后，再以Go实现高复杂度能力，避免过早优化。

### 数据迁移策略
- 前端localStorage → Supabase：以统一模型接口导出JSON并导入数据库；保留数据版本号和迁移脚本
- Supabase → Go迁移/共存：以API边界为单位逐步替换；通过事件总线或Webhooks保持一致性

### 安全与隐私
- 阶段2.1：使用Supabase RLS与行级加密（如必要）；明确数据最小化原则
- 阶段2.2：Go服务采用JWT/OAuth、审计日志与速率限制，关键数据加密存储

### 近期里程碑（与Milestone对齐）
- M1（当前）：完善前端本地持久化与可视化的最小版本
- M2：接入Supabase（Auth/DB/Storage），导入历史数据，开放云同步
- M3：定时任务（提醒与报告草稿），AI教练最小可行对话（上下文来自用户数据）
- M4：选取模块以Go实现（报告生成/批处理），搭建基础CI/CD与监控

